name: CI - Validate Pull Request
# Continuous Integration workflow for validating pull requests
# Runs solution checker on changed solutions

on:
  pull_request:
    paths:
      - 'solutions/**'

permissions:
  contents: read
  pull-requests: write

jobs:
  detect-changed-solutions:
    runs-on: ubuntu-latest
    outputs:
      solutions: ${{ steps.detect.outputs.solutions }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect changed solutions
      id: detect
      run: |
        # Get changed files in solutions directory
        CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep "^solutions/" || true)
        
        if [ -z "$CHANGED_FILES" ]; then
          echo "No solution changes detected"
          echo "has_changes=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # Extract unique solution names
        SOLUTIONS=$(echo "$CHANGED_FILES" | cut -d'/' -f2 | sort | uniq | jq -R -s -c 'split("\n")[:-1]')
        
        echo "Changed solutions: $SOLUTIONS"
        echo "solutions=$SOLUTIONS" >> $GITHUB_OUTPUT
        echo "has_changes=true" >> $GITHUB_OUTPUT

  validate-solutions:
    needs: detect-changed-solutions
    if: needs.detect-changed-solutions.outputs.has_changes == 'true'
    strategy:
      matrix:
        solution: ${{ fromJson(needs.detect-changed-solutions.outputs.solutions) }}
    uses: ./.github/workflows/00-solution-checker.yml
    with:
      solution_name: ${{ matrix.solution }}
    secrets:
      PowerPlatformSPN: ${{ secrets.PowerPlatformSPN }}

  pr-summary:
    needs: [detect-changed-solutions, validate-solutions]
    if: always()
    runs-on: ubuntu-latest
    steps:
    - name: Create PR Summary
      uses: actions/github-script@v7
      with:
        script: |
          const solutions = ${{ needs.detect-changed-solutions.outputs.solutions || '[]' }};
          const hasChanges = ${{ needs.detect-changed-solutions.outputs.has_changes || 'false' }};
          
          let summary = '## ðŸ” Solution Validation Summary\n\n';
          
          if (!hasChanges) {
            summary += 'âœ… No solution changes detected in this PR.\n';
          } else {
            summary += `ðŸ“¦ **Solutions Changed**: ${solutions.join(', ')}\n\n`;
            
            const validationJobs = ${{ toJson(needs.validate-solutions.result) }};
            
            solutions.forEach(solution => {
              const status = validationJobs === 'success' ? 'âœ… Passed' : 
                            validationJobs === 'failure' ? 'âŒ Failed' : 
                            'â³ Running';
              summary += `- **${solution}**: ${status}\n`;
            });
            
            summary += '\nðŸ’¡ **Next Steps**: ';
            if (validationJobs === 'success') {
              summary += 'All validations passed! Ready to merge.\n';
            } else if (validationJobs === 'failure') {
              summary += 'Please fix validation issues before merging.\n';
            } else {
              summary += 'Validation in progress...\n';
            }
          }
          
          // Add comment to PR
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('Solution Validation Summary')
          );
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: summary
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: summary
            });
          }
